#
# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari
# 
# This file is part of Honeybee.
# 
# Copyright (c) 2013-2015, Chris Mackey <Chris@MackeyArchitecture.com.com> 
# Honeybee is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published 
# by the Free Software Foundation; either version 3 of the License, 
# or (at your option) any later version. 
# 
# Honeybee is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.
# 
# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>


"""
Use this component to import the colored mesh results from a THERM simulation.  Note that, because the THERM API version is not free, you will have to open the file generated by run the "Write THERM File" component are run it yourself (maybe in the future, we will be able to launch it from the command line).
_
Before you run the file in THERM, make sure that you go to Options > Preferences > Simulation and ckeck "Save Conrad results file (.O)" in order to enure that your THERM simulation writes all results out in a format that this component understands.
-
Provided by Honeybee 0.0.57
    
    Args:
        _resultFileAddress: The resultFileAddress from the "Write THERM File" component.  Make sure that you have opened THERM and run your file before using this component. Also, before you run the file in THERM, make sure that you go to Options > Preferences > Simulation and ckeck "Save Conrad results file (.O)" in order to enure that your THERM simulation writes all results out in a format that this component understands.
        thermFileAddress_: An optional filepath to a THERM file that has been generated with the 'Honeybee_Write THERM File' component.  The header of this file contains information on the transformations used to map the original geometry between Rhino space and the THERM canvas.  As a result, connecting a file here ensures that imported results happen on top of the original Rhino geometry.  If no file address is connected here, the THERM results are imported with their THERM canvass coordinates.
        dataType_: An optional integer to set the type of data to import.  If left blank, this component will import the temperature data.  Choose from the following two options:
            0 - Temperature (temperature values at each point in C)
            1 - Heat Flux (heat flux values at each point in C)
        legendPar_: Optional legend parameters from the Ladybug "Legend Parameters" component.
        runIt_: Set boolean to "True" to run the component and import THERM results to Rhino/GH.
    Returns:
        readMe!: ...
        values: The numerical values of the results in either degrees C or W/m2 (depending on the dataYpe_ input of this component).
        points: The points of the mesh that THERM has generated.
        coloredMesh: A mesh of the original THERM geometry that is colored with the results.
        legend: A legend for the coloredMesh above. Connect this output to a grasshopper "Geo" component in order to preview this legend separately in the Rhino scene.  
        legendBasePt: The legend base point, which can be used to move the legend in relation to the newMesh with the grasshopper "move" component.
        title: The title text of the results.  Hook this up to a native Grasshopper 'Geo' component to preview it separately from the other outputs.
        titleBasePt: Point for the placement of the title, which can be used to move the title in relation to the chart with the native Grasshopper "Move" component.
"""

import Rhino as rc
import scriptcontext as sc
import os
import System
import Grasshopper.Kernel as gh
import math

ghenv.Component.Name = 'Honeybee_Read THERM Result'
ghenv.Component.NickName = 'readTHERM'
ghenv.Component.Message = 'VER 0.0.57\nDEC_30_2015'
ghenv.Component.Category = "Honeybee"
ghenv.Component.SubCategory = "12 | WIP"
#compatibleHBVersion = VER 0.0.56\nDEC_30_2015
#compatibleLBVersion = VER 0.0.59\nFEB_01_2015
try: ghenv.Component.AdditionalHelpFromDocStrings = "4"
except: pass


w = gh.GH_RuntimeMessageLevel.Warning
e = gh.GH_RuntimeMessageLevel.Error



def checkTheInputs():
    lb_preparation = sc.sticky["ladybug_Preparation"]()
    
    #Check if the result file exists.
    if not os.path.isfile(_resultFileAddress):
        warning = "Cannot find the result file. Check the location of the file on your machine. \n If it is not there, make sure that you have opened THERM and run your file before using this component. \n Also, before you run the file in THERM, make sure that you go to Options > Preferences > Simulation and ckeck 'Save Conrad results file (.O).'"
        print warning
        ghenv.Component.AddRuntimeMessage(e, warning)
        return -1
    
    #If there is a thermFileAddress_ connected, check to make sure it exists and contains transformation data.
    planeReorientation = None
    unitsScale = None
    bufferTansl = rc.Geometry.Transform.Translation(0.067, -0.0615, 0)
    if thermFileAddress_ != None:
        if not os.path.isfile(_resultFileAddress):
            warning = "Cannot find the THERM file at the thermFileAddress_. \n Result geometry will not be imported to the location of the original Rhino geometry."
            print warning
            ghenv.Component.AddRuntimeMessage(w, warning)
        else:
            #Try to extract the transformations from the file header.
            thermFi = open(thermFileAddress_, 'r')
            for lineCount, line in enumerate(thermFi):
                if '<Notes>' in line and '</Notes>' in line:
                    if 'RhinoUnits-' in line and 'RhinoOrigin-' in line and 'RhinoXAxis-' in line:
                        origRhinoUnits = line.split(',')[0].split('RhinoUnits-')[-1]
                        origRhinoOrigin = line.split('),')[0].split('RhinoOrigin-(')[-1].split(',')
                        origRhinoXaxis = line.split('),')[1].split('RhinoXAxis-(')[-1].split(',')
                        origRhinoYaxis = line.split(')</Notes>')[0].split('RhinoYAxis-(')[-1].split(',')
                        
                        basePlane = rc.Geometry.Plane(rc.Geometry.Point3d(float(origRhinoOrigin[0]), float(origRhinoOrigin[1]), float(origRhinoOrigin[2])), rc.Geometry.Vector3d(float(origRhinoXaxis[0]), float(origRhinoXaxis[1]), float(origRhinoXaxis[2])), rc.Geometry.Vector3d(float(origRhinoYaxis[0]), float(origRhinoYaxis[1]), float(origRhinoYaxis[2])))
                        planeReorientation = rc.Geometry.Transform.ChangeBasis(basePlane, rc.Geometry.Plane.WorldXY)
                        
                        conversionFactor = lb_preparation.checkUnits()
                        conversionFactor = 1/conversionFactor
                        unitsScale = rc.Geometry.Transform.Scale(rc.Geometry.Plane.WorldXY, conversionFactor, conversionFactor, conversionFactor)
                    else:
                        warning = "Cannot find the transformation data in the header of the THERM file at the thermFileAddress_. \n Result geometry will not be imported to the location of the original Rhino geometry."
                        print warning
                        ghenv.Component.AddRuntimeMessage(w, warning)
            thermFi.close()
    
    #If there is an input for dataType_, check to make sure that it makes sense.
    dataType = 0
    if dataType_ != None:
        if dataType_ == 0 or dataType_ == 1: dataType = dataType_
        else:
            warning = "dataType_ must be either 0 or 1.'"
            print warning
            ghenv.Component.AddRuntimeMessage(e, warning)
            return -1
    
    return dataType, planeReorientation, unitsScale, bufferTansl


def main(dataType, planeReorientation, unitsScale, bufferTansl):
    #Import the class.
    lb_preparation = sc.sticky["ladybug_Preparation"]()
    lb_visualization = sc.sticky["ladybug_ResultVisualization"]()
    
    #Create lists to be filled up with data from the file.
    pointData = []
    elementData = []
    values = []
    disjointedIndices = []
    pointTrigger = False
    elementTrigger = False
    valuesTrigger = False
    disjointTrigger = False
    
    #Parse the result file into the lists.
    resultFile = open(_resultFileAddress, 'r')
    for lineCount, line in enumerate(resultFile):
        if 'node number    x1-coordinate     x2-coordinate      temperature' in line: pointTrigger = True
        elif 'elem. no.   i      j      k      l      matl. no.    matl. angle       volume' in line: elementTrigger = True
        elif 'node    temperature          x-flux         y-flux' in line: valuesTrigger = True
        elif 'warning --- mesh is disjoint at these nodes' in line: disjointTrigger = True
        elif '********************************************************************************' in line:
            pointTrigger = False
            elementTrigger = False
            disjointTrigger = False
        elif 'Boundary Element Edge Data: nseg=     168  type=conv' in line: valuesTrigger = False
        elif pointTrigger == True:
            try:
                columns = line.split('    ')
                xCoord = float(columns[-3])
                yCoord = float(columns[-2])
                #if yCoord < -0.1: print columns
                pointData.append(rc.Geometry.Point3d(xCoord, yCoord, 0))
            except: pass
        elif elementTrigger == True:
            try:
                columns = line.split('    ')
                i = int(columns[2])
                j = int(columns[3])
                k = int(columns[4])
                l = int(columns[5])
                elementData.append([i, j, k, l])
            except: pass
        elif valuesTrigger == True:
            try:
                columns = line.split('   ')
                if dataType == 0: values.append(float(columns[-3]))
                else: values.append(math.sqrt((math.pow(float(columns[-1]),2))+(math.pow(float(columns[-2]),2))))
            except: pass
        elif disjointTrigger == True:
            columns = line.split('  ')
            for val in columns:
                try: disjointedIndices.append(int(val))
                except: pass
    
    resultFile.close()
    
    #Remove any disjointed points from each list.
    for count, index in enumerate(disjointedIndices):
        del pointData[index-1-count]
        del values[index-1-count]
    
    #If we have a Rhino transform from the thermFile, transform all of the point data.
    if planeReorientation != None:
        for point in pointData:
            point.Transform(bufferTansl)
            point.Transform(unitsScale)
            point.Transform(planeReorientation)
    
    #Build up a mesh from the point and element data.
    feMesh = rc.Geometry.Mesh()
    for point in pointData:
        feMesh.Vertices.Add(point)
    for face in elementData:
        feMesh.Faces.AddFace(face[0]-1, face[1]-1, face[2]-1, face[3]-1)
    
    #Color the mesh with the data and create a legend/title.
    #Read the legend parameters.
    lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar_, False)
    if len(legendPar_) == 0 or legendPar_[3] == []: customColors = lb_visualization.gradientLibrary[20]
    colors = lb_visualization.gradientColor(values, lowB, highB, customColors)
    feMesh.VertexColors.CreateMonotoneMesh(System.Drawing.Color.Gray)
    for count, col in enumerate(colors):
        try: feMesh.VertexColors[count] = col
        except: pass
    
    #Get the bounding box of the secene that will work in 3 dimensions.
    meshBB = rc.Geometry.BoundingBox(pointData)
    meshBox = rc.Geometry.Box(meshBB)
    bbDim = [meshBox.X[1]-meshBox.X[0], meshBox.Y[1]-meshBox.Y[0], meshBox.Z[1]-meshBox.Z[0]]
    bbDim.sort()
    plane = rc.Geometry.Plane.WorldXY
    plane.Origin = rc.Geometry.BoundingBox.Corner(meshBB, True, True, True)
    theInt =  rc.Geometry.Interval(0, bbDim[-1])
    sceneBox = rc.Geometry.Box(plane, theInt, theInt, theInt)
    sceneBox = sceneBox.ToBrep()
    
    #Create the legend.
    lb_visualization.calculateBB([sceneBox], True)
    if dataType == 0: legendTitle = 'C'
    else: legendTitle = 'W/m2'
    if legendBasePoint == None: legendBasePoint = lb_visualization.BoundingBoxPar[0]
    legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(values, lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)
    legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)
    legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)
    
    #Create title.
    if dataType == 0: titleTxt = '\n\nTemperature \n' 'THERM Simulation'
    else: titleTxt = '\n\nHeat Flow \n' 'THERM Simulation'
    titleBasePt = lb_visualization.BoundingBoxPar[5]
    titleTextCurve = lb_visualization.text2srf([titleTxt], [titleBasePt], legendFont, textSize, legendBold)
    
    
    return values, pointData, feMesh, [legendSrfs] + lb_preparation.flattenList(legendTextCrv), legendBasePoint, lb_preparation.flattenList(titleTextCurve), titleBasePt




#If Ladybug is not flying or is an older version, give a warning.
initCheck = True

#Ladybug check.
if not sc.sticky.has_key('ladybug_release') == True:
    initCheck = False
    print "You should first let Ladybug fly..."
    ghenv.Component.AddRuntimeMessage(w, "You should first let Ladybug fly...")
else:
    try:
        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): initCheck = False
        if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): initCheck = False
    except:
        initCheck = False
        warning = "You need a newer version of Ladybug to use this compoent." + \
        "Use updateLadybug component to update userObjects.\n" + \
        "If you have already updated userObjects drag Ladybug_Ladybug component " + \
        "into canvas and try again."
        ghenv.Component.AddRuntimeMessage(w, warning)


#If the intital check is good, run the component.
if initCheck and _resultFileAddress and _runIt:
    initInputs = checkTheInputs()
    if initInputs != -1:
        dataType, planeReorientation, unitsScale, bufferTansl = initInputs
        result = main(dataType, planeReorientation, unitsScale, bufferTansl)
        if result != -1:
            values, points, coloredMesh, legend, legendBasePt, title, titleBasePt = result

ghenv.Component.Params.Output[2].Hidden = True
ghenv.Component.Params.Output[5].Hidden = True
ghenv.Component.Params.Output[7].Hidden = True