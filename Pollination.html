<!DOCTYPE html>

<html>
	
	<head>
		<!-- Here are the examples that I used:
			http://www.columbia.edu/~cme2126/datavisuals/bigdata_parallelcoordinates.html
			https://syntagmatic.github.io/parallel-coordinates/
		-->

		<title>Pollination</title>

		<script src="./pc_source_files/d3/d3.v3.min.js" charset="utf-8"></script> <!-- D3 -->
		<script src = "./pc_source_files/d3/d3.parcoords.js"></script> <!-- D3 Parallel Coordinates Library -->
		<link rel="stylesheet" type="text/css" href="./pc_source_files/css/d3.parcoords.css"> <!-- D3 Parallel Coordinates CSS -->
		<!-- <link rel="stylesheet" type="text/css" href="./pc_source_files/css/pollination.css"> -->
		<script src="./pc_source_files/d3/d3.underscore.math.js"></script>
    	<script src="./pc_source_files/d3/d3.divgrid.js"></script> <!-- D3 table grid -->
    	<style>
    		#header{
    			font-family: sans-serif;
    		}
			#wrapper {
			   position: relative;
			   float: left;
			   top: 20px;
			   font-family: sans-serif;
			   font-size: 10px;
			}
			
			/* data table styles */
			#grid {
				font-family: sans-serif;
				height: 198px;
				color:black;
				clear: both; 
				position:relative;
				top: 60px;
				left: 75px;
				right: 20px;
				}
			.row, .header { clear: left; font-size: 14px; line-height: 18px; height: 20px; margin: 5px; width:90% }
			.row:hover { font-weight: bold;  color: orange;}
			.row:nth-child(odd) { background: rgba(0,0,0,0.05); }
			.header { font-weight: bold;}
			.cell { float: left;
					overflow: hidden;
					white-space: nowrap;
					width: 100px;
					height: 22px;
				}

			#tooltip{
				font-family: sans-serif;
				font-size: 14px;
				font-weight: bold;
				color:black;
			}

    	</style>
	</head>
	
	<body>

  		<div id="header">
  			<img src="http://goo.gl/qqjiVB" style="width: 7%; height: 7%; vertical-align:middle; float:right">
  			<h1>Pollination</h1>
  			<span class="large">Use Pollination to explore results of parametric studies. </span>
			<span>Load a .csv file from your system or download an example file from <a href= "https://dl.dropboxusercontent.com/u/16228160/equestResults.csv"> here</a>! </span>
  			<br><br>
  			
  			<input type="file" id="csv-file" name="files"/>
  		</div>
		<div id="whitespace" style="width:100%; height:5px"></div>
    	<div id="wrapper" class="parcoords" style="width:100%; height:340px"></div>
    	<div id="grid" class="parcoords" style="width:100%;height:340px"></div>
		
		<script>
			var rawData;
			var totalWidth = .9 * window.innerWidth - 75;

			var color_set = d3.scale.linear()
				.range(["#3182bd", "#f33"]);
		
			window.onload = function() {
			
				var fileInput = document.getElementById('csv-file');

				fileInput.addEventListener('change', function(e) {
				
					var file = fileInput.files[0];
					var reader = new FileReader();
					
					var regex = /^([a-zA-Z0-9\s_\\.\-:])+(.csv|.txt)$/;
    				
    				if (regex.test(file.name.toLowerCase())) {

					reader.onload = function(e) {
						
						var rawData = reader.result;
				
						// parse data						
						var data = d3.csv.parse(rawData);
				
						// remove old graph if any
						d3.select('#wrapper svg')
					 			.remove();


						// collect text for first column to adjust left margin
						var firstCell = data.map(function(d){return d3.values(d)[0]});
						
						// find the longest text size in the first row to adjust left margin
						var textLength = 0;
						firstCell.forEach(function(d){
							if (d.length > textLength) textLength = d.length;
						});
						

						// get parallel coordinates
						graph = d3.parcoords()('#wrapper')
		                	.data(data)
		                		.margin({ top: 25, left: 3 * textLength, bottom: 10, right: 0 })
		                		.alpha(0.6)
		                		.mode("queue")
		                		.rate(5)
		                		.render()
		                		.brushMode("1D-axes")  // enable brushing
		                		//.reorderable() // I removed this for now as it can mess up with tooltips
		                		.interactive();

		                
		                // set the initial coloring based on the 3rd column
		                update_colors(d3.keys(data[0])[2]);

		                 // click label to activate coloring
						graph.svg.selectAll(".dimension")
						    .on("click", update_colors)
						    .selectAll(".label")
						    	.style("font-size", "14px"); // change font sizes of selected lable

						// add table
						var grid = d3.divgrid();

		      			d3.select("#grid")
		          			.datum(data)
		          			.call(grid)
		          			.selectAll(".row")
		          			.on("mouseover", function(d) {
		          				// remove tooltips if any
		          				cleanTooltip();
						    	removeRowHighlight();
		          				graph.highlight([d]);})
		            		.on("mouseout", graph.unhighlight);

		          		// set width size for grid based on number of columns
		          		// This is good for now but at some point I can make it smarter
		          		// I need to add more checks here and make sure that the size will be adjusted
		          		// for columns with long contents and shrink for the rest.
		          		// d3.selectAll(".col-0.cell").style("width", (textLength*8) + "px");
		          		cellWidth = parseInt(totalWidth/d3.keys(data[0]).length);
		          		d3.selectAll(".cell").style("width", (cellWidth + "px"));


		          		// update grid on brush event
		          		graph.on("brush", function(d) {
		        			d3.select("#grid")
		          				.datum(d)
		          				.call(grid)
		          				.selectAll(".row")
		          				.on("mouseover", function(d) {
									// remove tooltips if any
		          					cleanTooltip();
		          					removeRowHighlight();
		          					graph.highlight([d]);})
		          				.on("mouseout", graph.unhighlight);

		          			// re-adjust size of the cell
		          			d3.selectAll(".cell").style("width", (cellWidth + "px"));
		          			// remove tooltips if any
		          			cleanTooltip();
		          			removeRowHighlight();
						});


						// Add highlight for every line on click
						var svg = d3.select("svg");
						var margins = graph.margin();
						
						function getCenPts(){
							// this function returns centroid points for all brushed data. I had to change the source
							// for parallelcoordinates and make compute_centroids public
							// I assume this should be already somewhere in graph and I don't need to recalculate it
							// but I couldn't find it so I just wrote this for now
							var graphCentPts = [];
							var activeData = [];

							if (graph.brushed()!=false)
								{
									activeData = graph.brushed();
								}else{
									activeData = graph.data();
								}
							
							activeData.forEach(function(d){
								// this is a test for the first row of data
								var initCenPts = graph.compute_centroids(d).filter(function(d, i){return i%2==0;});
								
								// move points based on margins
								var cenPts = initCenPts.map(function(d){
									return [d[0] + margins["left"], d[1]+ margins["top"]]; 
								});

								graphCentPts.push(cenPts);
							});

							return [activeData, graphCentPts];
						}
						

						function isOnLine(startPt, endPt, testPt, tol){
							// check if test point is close enough to a line
							// between startPt and endPt. close enough means smaller than tolerance
							var x0 = testPt[0];
							var	y0 = testPt[1];
							var x1 = startPt[0];
							var	y1 = startPt[1];
							var x2 = endPt[0];
							var	y2 = endPt[1];
							var Dx = x2 - x1;
        					var Dy = y2 - y1;
        					var delta = Math.abs(Dy*x0 - Dx*y0 - x1*y2+x2*y1)/Math.sqrt(Math.pow(Dx, 2) + Math.pow(Dy, 2)); 
							//console.log(delta);
							if (delta <= tol) return true;
							return false;
						}

						function findAxes(testPt, cenPts){
							// finds between which two axis the mouse is
							var x = testPt[0];
							var y = testPt[1];

							// make sure it is inside the range of x
							if (cenPts[0][0] > x) return -1;
							if (cenPts[cenPts.length-1][0] < x) return -1;

							// find between which segment the point is
							for (var i=0; i<cenPts.length; i++){
								if (cenPts[i][0] > x) return i;
							}
						}

						function cleanTooltip(){
							// removes any object under #tooltip is
							svg.selectAll("#tooltip")
						    	.remove();
						}



						function addTooltip(clicked, clickedCenPts){
							
							// sdd tooltip to multiple clicked lines
						    var clickedDataSet = [];

						    // get all the values into a single list
						    // I'm pretty sure there is a better way to write this is Javascript
						    for (var i=0; i<clicked.length; i++){
						    	for (var j=0; j<clickedCenPts[i].length; j++){
						    		var text = d3.values(clicked[i])[j];
						  			// not clean at all!
						  			var x = clickedCenPts[i][j][0];
						  			var y = clickedCenPts[i][j][1];
						  			clickedDataSet.push([x, y, text]);
								}
							};

							// add rectangles
							svg.selectAll("rect[id='tooltip']")
				                	.data(clickedDataSet).enter()
				                	.append("rect")
				                	.attr("x", function(d) { return d[0] - d[2].length * 5;})
									.attr("y", function(d) { return d[1] - 25; })
									.attr("rx", "2")
									.attr("ry", "2")
									.attr("id", "tooltip")
									.attr("fill", "grey")
									.attr("opacity", 0.9)
									.attr("width", function(d){return d[2].length * 10;})
									.attr("height", "20px");

							// add text on top of rectangle
							svg.selectAll("text[id='tooltip']")
						    	.data(clickedDataSet).enter()
						    		.append("text")
									.attr("x", function(d) { return d[0];})
									.attr("y", function(d) { return d[1] - 10; })
									.attr("id", "tooltip")
									.attr("fill", "white")
									.attr("text-anchor", "middle")
									.attr("font-size", "14px")
				                	.text( function (d){ return d[2];})
				            
						}

						function removeRowHighlight(){
							    	d3.selectAll("div.row")
							    		.style("color", "black")
							    		.style("font-weight", "normal");
							    }

						// click event for lines
						svg.on("click", function() {
						    
						    clickedPt = d3.mouse(this);
						    // console.log(clickedPt);
						    // find between which axes the point is
						    var activeData,
						    	graphCentPts;

						   	var dataAndCenPts = getCenPts();
						   	activeData = dataAndCenPts[0];
							graphCentPts = dataAndCenPts[1];

						    var axeNum = findAxes(clickedPt, graphCentPts[0]);
						    //console.log(axeNum);
						    var clicked = [];
						    var clickedCenPts = [];
						    var clickedRows = [];

						    if (graphCentPts.length==0) return;

						    graphCentPts.forEach(function(d, i){
							    if (isOnLine(d[axeNum-1], d[axeNum], clickedPt, 2)){
							    	clicked.push(activeData[i]);
							    	clickedCenPts.push(graphCentPts[i]);
							    	clickedRows.push(i);
							    }

							if (clicked.length!=0){
								// clean if anything is already selceted
						    	cleanTooltip();
						    	removeRowHighlight();	
							    graph.highlight(clicked);
							    addTooltip(clicked, clickedCenPts);
							    // highlight row in grid
							    selectedRows = d3.selectAll("div.row").filter(function(d, i){return clickedRows.indexOf(i)>-1;});
							    selectedRows.style("color", "orange").style("font-weight", "bold");
							}
							else
							{
						    	graph.unhighlight();
						    	cleanTooltip();
						    	// remove highlight in grid
						    	removeRowHighlight();
							}
							});
						});
						
					}
				}else{

					alert("Please upload a valid CSV file!");
				}

				reader.readAsText(file);
				});
			}


		// update color and font weight of chart based on axis selection
        // modified from here: https://syntagmatic.github.io/parallel-coordinates/
        function update_colors(dimension) { 
			// change the fonts to bold
			graph.svg.selectAll(".dimension")
				.style("font-weight", "normal")
				.filter(function(d) { return d == dimension; })
					.style("font-weight", "bold");

			// change color of lines
			// set domain of color scale
			var values = graph.data().map(function(d){return parseFloat(d[dimension])}); 
			color_set.domain([d3.min(values), d3.max(values)]);
			
			// change colors for each line
			graph.color(function(d){return color_set([d[dimension]])}).render();
		};		

		</script>

	</body>

</html>


